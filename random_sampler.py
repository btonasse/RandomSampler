import random
from datetime import date


class RandomSampler:
    '''
    The purpose of this class is to pick a "random" number of elements of a list every week,
    while making sure that the same elements are not picked twice before the list is exhausted.

    This is achieved by calculating the elapsed time between the time of instantiation and an arbitrary root date
    and using this to generate a new fixed seed every time the list is exhausted.

    Usage:
    Instantiate this class with a fixed list of elements and a number of samples per week.
    To get a unique sample, call `get_sample()` on the instance

    Notes:
    1. This functionality relies on the date at the time of instantiation to determine the seed of the list shuffler.
    2. It also assumes that the list is fixed is constant (elements should always be in the same order).
    3. If an element is added or removed from the list in between runs, you might get unreliable results until the next fixed seed is generated.
    4. If the number of elements is not a multiple of the number of weekly samples, leftovers will be inserted at the top of the list upon the next seed reset.
    '''
    ROOT_DATE = date(2021, 7, 1)
    def __init__(self, elements: list, samples_per_week: int):
        # The list of elements to sample from
        self.elements = elements
        
        # How many elements to pick every week
        self.samples_per_week = samples_per_week
        
        # How many weeks have to pass until all elements have been picked once
        self.weeks_to_exhaust_samples = len(self.elements) // self.samples_per_week
        
        # Elapsed time since ROOT_DATE
        self.elapsed_days = self._get_elapsed_days()
        
        # Shuffle the list of elements
        self.seed = self._calculate_seed()
        self.shuffled_elements = self._shuffle_list(self.seed)

        # Prioritize leftovers from last seed
        self._insert_leftovers()
        


    def _get_elapsed_days(self) -> int:
        '''
        Get number of elapsed days since arbitrary ROOT_DATE
        '''
        root_date = self.ROOT_DATE
        today = date.today()
        delta = today - root_date
        return delta.days

    def _calculate_seed(self) -> int:
        '''
        Return a seed for shuffling the list of elements.
        
        The seed is reset when all elements have been picked once (not counting leftovers that would result in an IndexError).
        The reset date is calculated by tracking the number of days elapsed since an arbitrary constant date
        and comparing it to the number of days necessary to pick all elements once (again, not counting leftovers that would result in an IndexError). 
        The actual seed is the number of elapsed days when the reset occurs.
    
        Example:
        The list of elements contains 7 items, and each week two are picked.
        Therefore it takes 3 weeks for all but one element to be picked.
        Once 3 weeks have passed (21 days), the seed will reset to this number of days.
        '''
        days_since_seed_was_reset = self.elapsed_days % (self.weeks_to_exhaust_samples*7)
        last_seed = self.elapsed_days - days_since_seed_was_reset
        return last_seed

    def _shuffle_list(self, seed: int) -> list:
        '''
        Shuffles a copy of the list of elements given a fixed seed.
        '''
        random.seed(seed)
        shuffled_elements = self.elements.copy() # A shallow copy is needed because shuffle() modifies the list in place
        random.shuffle(shuffled_elements)
        return shuffled_elements

    def _insert_leftovers(self) -> None:
        '''
        Look at shuffled list generated by previous seed.
        If there were any leftovers, move them to the top of the current shuffled list.
        '''
        leftovers = len(self.elements) % self.samples_per_week
        if not leftovers:
            return
       
        previous_seed = self.seed - self.weeks_to_exhaust_samples*7
        previous_shuffled_list = self._shuffle_list(previous_seed)
        leftovers_to_insert = previous_shuffled_list[-leftovers:]

        # Remove leftovers from current list
        self.shuffled_elements = [x for x in self.shuffled_elements if x not in leftovers_to_insert]
        # Insert leftovers into front of list
        self.shuffled_elements = leftovers_to_insert + self.shuffled_elements

    def get_sample(self) -> list:
        '''
        Get a number of elements from the shuffled list.
        The size of the sample is determined at instantiation (self.samples_per_week)
        Which elements to pick is decided by how many days have elapsed since the seed was modified
        '''
        picked_elements = []
        
        weeks_since_seed_was_reset = (self.elapsed_days//7) % self.weeks_to_exhaust_samples
        start_index = weeks_since_seed_was_reset * self.samples_per_week
        end_index = start_index + self.samples_per_week
        
        try:
            picked_elements = self.shuffled_elements[start_index:end_index]
        except IndexError:
            print(f'''Not enough elements to pick. Variables:
            Weeks since seed was reset: {weeks_since_seed_was_reset}
            Start and end slice indices: {start_index}:{end_index}
            Length of elements list: {len(self.elements)}
            ''')
            raise

        return picked_elements



if __name__ == '__main__':
    elements = [n for n in range(7)]
    x = RandomSampler(elements, 2)

    print(f'Elapsed days since arbitrary date: {x.elapsed_days}')
    print(f'Elapsed weeks since arbitrary date: {x.elapsed_days//7}')
    print(f'Weeks until all elements are used: {x.weeks_to_exhaust_samples}')
    print(f'Seed is: {x.seed}')

    print(f'elements: {x.elements}')
    print(f'Shuffled elements: {x.shuffled_elements}')

    print(f'Sample for this week: {x.get_sample()}')

