import random
from datetime import date
from random_sampler.logger import logger_setup


class RandomSampler:
    '''
    The purpose of this class is to pick a "random" number of elements of a list every week,
    while making sure that the same elements are not picked twice before the list is exhausted.

    This is achieved by calculating the elapsed time between the time of instantiation and an arbitrary root date
    and using this to generate a new fixed seed every time the list is exhausted.

    Usage:
    Instantiate this class with a fixed list of elements and a number of samples per week.
    To get a unique sample, call `get_sample()` on the instance

    Notes:
    1. This functionality relies on the date at the time of instantiation to determine the seed of the list shuffler.
    2. It also assumes that the list is fixed is constant (elements should always be in the same order).
    3. If an element is added or removed from the list in between runs, you might get unreliable results until the next fixed seed is generated.
    4. If the number of elements is not a multiple of the number of weekly samples, leftovers will be inserted at the top of the list upon the next seed reset.
    '''
    ROOT_DATE = date(2021, 7, 1)
    logger = logger_setup('Sampler', 'sampler.log')
    
    def __init__(self, elements: list, samples_per_week: int):
        # The list of elements to sample from
        self.elements = elements
        
        # How many elements to pick every week
        self.samples_per_week = samples_per_week
        
        # How many weeks have to pass until all elements have been picked once
        self.weeks_to_exhaust_samples = len(self.elements) // self.samples_per_week
        
        self.logger.info(f'Sampler set up with following parameters:\n'
               f'\tRoot date: {self.ROOT_DATE}\n'
               f'\tSamples per week: {self.samples_per_week}\n'
               f'\tWeeks until all elements are used: {self.weeks_to_exhaust_samples}\n'
               f'\tElements: {self.elements}\n'
               f'\tCurrent date: {date.today()}')
        
        # Elapsed time since ROOT_DATE
        self.elapsed_days = self._get_elapsed_days()
        self.logger.debug(f'Elapsed days since root rate: {self.elapsed_days}')
        # Shuffle the list of elements
        self.seed = self._calculate_seed()
        self.shuffled_elements = self._shuffle_list(self.seed)

        # Prioritize leftovers from last seed
        self._insert_leftovers()
        self.logger.debug(f"Elements are ordered like this this week: {self.shuffled_elements}")

    def _get_elapsed_days(self) -> int:
        '''
        Get number of elapsed days since arbitrary ROOT_DATE
        '''
        root_date = self.ROOT_DATE
        today = date.today()
        delta = today - root_date
        return delta.days

    def _calculate_seed(self) -> int:
        '''
        Return a seed for shuffling the list of elements.
        
        The seed is reset when all elements have been picked once (not counting leftovers that would result in an IndexError).
        The reset date is calculated by tracking the number of days elapsed since an arbitrary constant date
        and comparing it to the number of days necessary to pick all elements once (again, not counting leftovers that would result in an IndexError). 
        The actual seed is the number of elapsed days when the reset occurs.
    
        Example:
        The list of elements contains 7 items, and each week two are picked.
        Therefore it takes 3 weeks for all but one element to be picked.
        Once 3 weeks have passed (21 days), the seed will reset to this number of days.
        '''
        days_since_seed_was_reset = self.elapsed_days % (self.weeks_to_exhaust_samples*7)
        last_seed = self.elapsed_days - days_since_seed_was_reset
        self.logger.debug(f"Days since seed was last reset: {days_since_seed_was_reset}. This week's seed: {last_seed}")
        return last_seed

    def _shuffle_list(self, seed: int) -> list:
        '''
        Shuffles a copy of the list of elements given a fixed seed.
        '''
        random.seed(seed)
        shuffled_elements = self.elements.copy() # A shallow copy is needed because shuffle() modifies the list in place
        random.shuffle(shuffled_elements)
        return shuffled_elements

    def _insert_leftovers(self) -> None:
        '''
        Look at shuffled list generated by previous seed.
        If there were any leftovers, move them to the top of the current shuffled list.
        '''
        leftovers = len(self.elements) % self.samples_per_week
        if not leftovers:
            return
       
        previous_seed = self.seed - self.weeks_to_exhaust_samples*7
        previous_shuffled_list = self._shuffle_list(previous_seed)
        leftovers_to_insert = previous_shuffled_list[-leftovers:]
        self.logger.debug(
            f"There are {leftovers} leftover elements from previous week.\n"
            f"\tQueue from previous week: {previous_shuffled_list}\n"
            f"\tQueue from this week: {self.shuffled_elements}\n"
            f"\tLeftover elements from previous week: {leftovers_to_insert}"
        )

        # Remove leftovers from current list
        self.shuffled_elements = [x for x in self.shuffled_elements if x not in leftovers_to_insert]
        # Insert leftovers into front of list
        self.shuffled_elements = leftovers_to_insert + self.shuffled_elements

    def get_sample(self) -> list:
        '''
        Get a number of elements from the shuffled list.
        The size of the sample is determined at instantiation (self.samples_per_week)
        Which elements to pick is decided by how many days have elapsed since the seed was modified
        '''
        picked_elements = []
        
        weeks_since_seed_was_reset = (self.elapsed_days//7) % self.weeks_to_exhaust_samples
        start_index = weeks_since_seed_was_reset * self.samples_per_week
        end_index = start_index + self.samples_per_week
        
        try:
            picked_elements = self.shuffled_elements[start_index:end_index]
            self.logger.debug(f"This week's sample: {picked_elements}")
        except IndexError:
            self.logger.error(
                f'Not enough elements to pick. Variables\n:'
                f'\tWeeks since seed was reset: {weeks_since_seed_was_reset}\n'
                f'\tStart and end slice indices: {start_index}:{end_index}\n'
                f'\tLength of elements list: {len(self.elements)}\n'
            )
            raise

        return picked_elements